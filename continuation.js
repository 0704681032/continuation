var util = require('util');
var escodegen = require('escodegen');

var meta = require('./package.json');
var parser = require('./lib/parser');
var traverse = require('./lib/traverse');
var helpers = require('./lib/helpers');
var Program = require('./lib/syntax/Program');
  
var header = '/* Generated by Continuation.js v' + meta.version + ' */\n';

exports.compile = function (origCode, options) {
  if (!options) {
    options = {};
  }
  
  var indent = '  ';
  if (options.tabIndent) {
    indent = '\t';
  } else if (options.indentSpaces) {
    indent = Array(options.indentSpaces + 1).join(c);
  }
  
  //Wrap whole file into a function
  var code = '(function () {\n' + origCode + '\n}).call(this);\n';
  
  if (options.compileMark && code.indexOf('use continuation') === -1) {
    //Mark literal not found in code
    return origCode;
  }
  
  helpers.reset();
  var ast = parser.parse(code);
  
  if (options.compileMark) {
    //Traverse ast and find compile mark
    if (!findCompileMark(ast)) {
      return origCode;
    }
  }
  
  if (!options.force && !transformNeeded(ast)) {
    return header + origCode;
  }
  
  ast.normalize();
  //console.error(util.inspect(ast, false, null, true));
  ast.transform();
  //console.error(util.inspect(ast, false, null, true));
  
  ast = new Program(ast.body[0].expression.callee.object.body.body);

  //ast = escodegen.attachComments(ast, ast.comments, ast.tokens);
  code = escodegen.generate(ast, {
    format: {
      indent: {
        style: indent,
        base: 0
      },
    },
    comment: true,
  });
  
  return header + code;
};

//Alias
exports.transform = exports.compile;

var findCompileMark = function (ast) {
  var found = false;
  traverse(ast, function (node) {
    if (node.type === 'ExpressionStatement') {
      if (node.expression.type === 'Literal' && node.expression.value === 'use continuation') {
        found = true;
      }
    }
    return node;
  });
  return found;
};

var transformNeeded = function (ast) {
  var needed = false;
  traverse(ast, function (node) {
    if (node.type === 'CallExpression') {
      node.arguments.forEach(function (argument) {
        if (argument.type === 'CallExpression' && argument.callee.type === 'Identifier') {
          if (argument.callee.name === helpers.contName || argument.callee.name === helpers.obtainName) {
            needed = true;
          }
        }
      });
    }
    return node;
  });
  return needed;
};
